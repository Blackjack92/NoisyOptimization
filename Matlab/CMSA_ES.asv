% Name:   CMSA_ES
% Author: Kevin Wallis
%--------------------------------------------------------------------------
%| Input parameters                                                       |
%--------------------------------------------------------------------------
%| Name                | Type        | Description                        |
%--------------------------------------------------------------------------
%| sigma_init          | Real        | Scaling factor/ Mutation strength  |
%| y_init              | [N]         | Initialization vector              |
%| mu_init             | Integer     | Number of parents                  |
%| theta_init          | Real        | Ratio between mu/lambda            |
%--------------------------------------------------------------------------
%| Output parameters                                                      |
%--------------------------------------------------------------------------
%| Name                | Type        | Description                        |
%--------------------------------------------------------------------------
%| y_opt               | [N]         | Optimal output vector              |
%| f_dyn               | [M]         | Fitness value after each run       |
%| noisy_f_dyn         | [M]         | Noisy fitness value after each run |
%| sigma_dyn           | [M]         | Mutation strength after each run   |
%| y_dyn               | [M x N]     | y vector after each run            |
%| lambda_dyn          | [M]         | Number of offsprings after each run|
%| noisy_f_name        | String      | Noisy function name                |
%| goal_f_name         | String      | Goal function name                 |
%--------------------------------------------------------------------------
function [y_opt, f_dyn, noisy_f_dyn, sigma_dyn, y_dyn, lambda_dyn] = ...
    CMSA_ES(sigma_init, y_init, mu_init, theta_init, noisy_f_name, goal_f_name)
    
    % Initialize input parameters
    parent.sigma = sigma_init;
    parent.y = y_init;
    n = length(y_parent);
    mu = mu_init;
    lambda = floor(mu/theta_init);
    
    % Initialize output parameters
    y_opt = [];
    f_dyn = [];
    noisy_f_dyn = [];
    sigma_dyn = [];
    y_dyn = [];
    lambda_dyn = [];
    
    % Initialize covariance matrix
    C = eye(n);
    adjacence_C = 1; 
    
    % Initialize tau
    tau_sigma = 1/sqrt(2*n);
    tau_c = 1 + n*(n+1)/(2*mu);
    
    % Initialize number of runs
    numberOfRuns = 1000;
    
    % Main loop
    while (numberOfRuns > 0) 
       numberOfRuns = numberOfRuns - 1;
       
       offspringPopulation = [];
       % Generate offsprings
       for l=1:lambda
           offspring.sigma = sigma * exp(tau_sigma*randn(1));
           offspring.s = chol(C)' * randn(n,1);
           offspring.z = offspring.sigma .* offspring.s;
           offspring.y = parent.y + offspring.z;
           offspring.f = feval(noisy_f_name, offspring.y);
           offspringPopulation(l) = offspring;
       end
       
        % Ordering and selection
        % TODO: check ordering
        ranks = RankPop(offspringPopulation, ordering);
        sum_sigma = 0;
        sum_y = 0; 
        sum_s = 0;
        for m=1:mu
          sum_sigma = sum_sigma + offspringPopulation(ranks(m)).sigma;
          sum_s = sum_s + offspringPopulation(ranks(m)).s;
          sum_y = sum_y + offspringPopulation(ranks(m)).y;
        end
        
        % Centroid evaluation
        parent.sigma = sum_sigma/mu;
        parent.s = sum_s ./ mu;
        parent.y = sum_y ./ mu;
        parent.f = feval(input.goal_f_name, Parent.y);
        
        % Covariance matrix update
        C = (1 - 1/tau_c) .^ adjacence_C.*C + adjacence_C/tau_c.*(parent.s*parent.s');
    end
end